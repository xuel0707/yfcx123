/**
 * Copyright 2013-2024 the original author or authors from the JHipster project.
 *
 * This file is part of the JHipster project, see https://www.jhipster.tech/
 * for more information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import BaseGenerator from '../base-application/index.js';
export default class HerokuGenerator extends BaseGenerator {
    hasHerokuCli: any;
    herokuAppName: any;
    herokuDeployType: any;
    herokuJavaVersion: any;
    herokuRegion: any;
    herokuAppExists: any;
    herokuSkipDeploy: any;
    herokuSkipBuild: any;
    dynoSize: any;
    constructor(args: any, options: any, features: any);
    beforeQueue(): Promise<void>;
    get initializing(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/base/tasks.js").TaskParamWithControl, "initializing" | "checkInstallation" | "herokuLogin">;
    get prompting(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/base/tasks.js").TaskParamWithControl, "askForApp" | "askForHerokuDeployType" | "askForHerokuJavaVersion">;
    get loading(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/base/tasks.js").TaskParamWithControl, "saveConfig">;
    get default(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").TaskParamWithEntities<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>, "gitInit" | "installHerokuDeployPlugin" | "herokuCreate" | "herokuAddonsCreate" | "configureJHipsterRegistry">;
    get writing(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").WritingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>, "copyHerokuFiles" | "addHerokuBuildPlugin" | "addHerokuMavenProfile">;
    get end(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>, "productionBuild" | "productionDeploy">;
    /**
     * TODO drop when dropped from gae, azure-spring-cloud and heroku generators
     * @private
     * Add a new Maven profile.
     *
     * @param {string} profileId - profile ID
     * @param {string} other - explicit other thing: build, dependencies...
     */
    addMavenProfile(profileId: any, other: any): void;
    /**
     * @param  {string} command
     * @param  {import('execa').Options} opt
     * @returns {ReturnType<BaseGenerator['spawnCommand']>}
     */
    spawnHerokuCommand(command: any, opt: any): any;
    /**
     * @param  {string[]} args
     * @param  {import('execa').Options} opt
     * @returns {ReturnType<BaseGenerator['spawn']>}
     */
    spawnHeroku(args: any, opt: any): any;
    /**
     * @template {{stdout: any; stderr: any}} T
     * @param {T} child
     * @param {(chunk: any) => void} child
     * @returns {T}
     */
    printChildOutput(child: any, log?: (data: any) => import("@yeoman/types").Logger): any;
    checkAddOnReturn({ addOn, stdout, stderr }: {
        addOn: any;
        stdout: any;
        stderr: any;
    }): void;
}
