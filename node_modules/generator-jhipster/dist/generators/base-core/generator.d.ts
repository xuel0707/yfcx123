import type { GeneratorMeta } from '@yeoman/types';
import type { CopyOptions } from 'mem-fs-editor';
import type { Data as TemplateData, Options as TemplateOptions } from 'ejs';
import YeomanGenerator, { type ComposeOptions, type Storage } from 'yeoman-generator';
import type Environment from 'yeoman-environment';
import SharedData from '../base/shared-data.js';
import type { Logger } from '../base/support/index.js';
import type { CascatedEditFileCallback, EditFileCallback, EditFileOptions, JHipsterGeneratorFeatures, JHipsterGeneratorOptions, ValidationResult, WriteFileOptions } from '../base/api.js';
import { type JHipsterArguments, type JHipsterCommandDefinition, type JHipsterConfigs, type JHipsterOptions } from '../../lib/command/index.js';
import NeedleApi from '../needle-api.js';
import type BaseApplicationGenerator from '../base-application/generator.js';
import type { ApplicationConfiguration } from '../../lib/types/application/yo-rc.js';
/**
 * This is the base class for a generator for every generator.
 */
export default class CoreGenerator extends YeomanGenerator<JHipsterGeneratorOptions, JHipsterGeneratorFeatures> {
    static asPriority: (priorityName: string) => string;
    static INITIALIZING: string;
    static PROMPTING: string;
    static CONFIGURING: string;
    static COMPOSING: string;
    static COMPOSING_COMPONENT: string;
    static LOADING: string;
    static PREPARING: string;
    static POST_PREPARING: string;
    static DEFAULT: string;
    static WRITING: string;
    static POST_WRITING: string;
    static INSTALL: string;
    static POST_INSTALL: string;
    static END: string;
    context?: Record<string, any>;
    useVersionPlaceholders?: boolean;
    skipChecks?: boolean;
    ignoreNeedlesError?: boolean;
    experimental?: boolean;
    debugEnabled?: boolean;
    jhipster7Migration?: boolean | 'verbose' | 'silent';
    relativeDir: (from: string, to: string) => string;
    relative: (from: string, to: string) => string;
    readonly sharedData: SharedData<any>;
    readonly logger: Logger;
    jhipsterConfig: Record<string, any>;
    /**
     * @deprecated
     */
    jhipsterTemplatesFolders: string[];
    blueprintStorage?: Storage;
    /** Allow to use a specific definition at current command operations */
    generatorCommand?: JHipsterCommandDefinition;
    /**
     * @experimental
     * Additional commands to be considered
     */
    generatorsToCompose: string[];
    private _jhipsterGenerator?;
    private _needleApi?;
    env: Environment;
    log: Logger;
    _meta?: GeneratorMeta;
    constructor(args: string | string[], options: JHipsterGeneratorOptions, features: JHipsterGeneratorFeatures);
    /**
     * Override yeoman generator's usage function to fine tune --help message.
     */
    usage(): string;
    /**
     * @deprecated
     */
    get needleApi(): NeedleApi;
    /**
     * JHipster config with default values fallback
     */
    get jhipsterConfigWithDefaults(): Readonly<ApplicationConfiguration & Record<string, any>>;
    /**
     * Warn or throws check failure based on current skipChecks option.
     * @param message
     */
    handleCheckFailure(message: string): void;
    /**
     * Check if the JHipster version used to generate an existing project is less than the passed version argument
     *
     * @param {string} version - A valid semver version string
     */
    isJhipsterVersionLessThan(version: any): any;
    /**
     * Wrapper for `semver.lt` to check if the oldVersion exists and is less than the newVersion.
     * Can be used by blueprints.
     */
    isVersionLessThan(oldVersion: string | null, newVersion: string): any;
    /**
     * Get arguments for the priority
     */
    getArgsForPriority(priorityName: string): {
        control: import("../base/types.js").Control;
        source: any;
    }[] | {
        control: import("../base/types.js").Control;
        configChanges: {
            [k: string]: {
                newValue: any;
                oldValue: any;
            };
        };
    }[] | {
        control: import("../base/types.js").Control;
    }[];
    /**
     * Check if the generator should ask for prompts.
     */
    shouldAskForPrompts({ control }: {
        control: any;
    }): boolean;
    /**
     * Override yeoman-generator method that gets methods to be queued, filtering the result.
     */
    getTaskNames(): string[];
    queueCurrentJHipsterCommandTasks(): void;
    /**
     * Get the current Command Definition for the generator.
     * `generatorCommand` takes precedence.
     */
    getCurrentJHipsterCommand(): Promise<JHipsterCommandDefinition>;
    /**
     * Parse command definition arguments, options and configs.
     * Blueprints with command override takes precedence.
     */
    parseCurrentJHipsterCommand(): Promise<void>;
    /**
     * Prompts for command definition configs.
     * Blueprints with command override takes precedence.
     */
    promptCurrentJHipsterCommand(): Promise<any>;
    /**
     * Configure the current JHipster command.
     * Blueprints with command override takes precedence.
     */
    configureCurrentJHipsterCommandConfig(): Promise<void>;
    /**
     * Load the current JHipster command storage configuration into the context.
     * Blueprints with command override takes precedence.
     */
    loadCurrentJHipsterCommandConfig(context: any): Promise<void>;
    /**
     * @experimental
     * Compose the current JHipster command compose.
     * Blueprints commands compose without generators will be composed.
     */
    composeCurrentJHipsterCommand(): Promise<void>;
    parseJHipsterCommand(commandDef: JHipsterCommandDefinition): void;
    parseJHipsterOptions(options: JHipsterOptions | undefined, configs?: JHipsterConfigs | boolean, common?: boolean): void;
    parseJHipsterArguments(jhipsterArguments?: JHipsterArguments): void;
    prepareQuestions(configs?: JHipsterConfigs): ({
        storage: any;
        type: "input" | "list" | "confirm" | "checkbox";
        message: string | ((any: any) => string);
        when?: boolean | ((any: any) => boolean);
        default?: any | ((any: any) => any);
        filter?: any | ((any: any) => any);
        transformer?: any | ((any: any) => any);
        validate?: any | ((any: any) => any);
        name: string;
        choices: import("../../lib/command/types.js").JHispterChoices | undefined;
    } | {
        storage: any;
        type?: "input" | "list" | "checkbox" | "confirm" | undefined;
        message?: string | ((any: any) => string) | undefined;
        when?: boolean | ((any: any) => boolean);
        default?: any | ((any: any) => any);
        filter?: any | ((any: any) => any);
        transformer?: any | ((any: any) => any);
        validate?: any | ((any: any) => any);
        name: string;
        choices: import("../../lib/command/types.js").JHispterChoices | undefined;
    })[];
    /**
     * Generate a date to be used by Liquibase changelogs.
     *
     * @param {Boolean} [reproducible=true] - Set true if the changelog date can be reproducible.
     *                                 Set false to create a changelog date incrementing the last one.
     * @return {String} Changelog date.
     */
    dateFormatForLiquibase(reproducible?: boolean): string;
    /**
     * Alternative templatePath that fetches from the blueprinted generator, instead of the blueprint.
     */
    jhipsterTemplatePath(...path: string[]): string;
    /**
     * Compose with a jhipster generator using default jhipster config.
     * @return {object} the composed generator
     */
    composeWithJHipster<const G extends string>(gen: G, options?: ComposeOptions<BaseApplicationGenerator>): Promise<BaseApplicationGenerator<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>, {
        InitializingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        PromptingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        ConfiguringTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        ComposingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        LoadingTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplicationDefaults<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingTaskParam: import("../../lib/types/application/tasks.js").PreparingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        ConfiguringEachEntityTaskParam: import("../../lib/types/application/tasks.js").ConfiguringEachEntityTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        LoadingEntitiesTaskParam: import("../../lib/types/application/tasks.js").LoadingEntitiesTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingEachEntityTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingEachEntityFieldTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityFieldTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingEachEntityRelationshipTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityRelationshipTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostPreparingEachEntityTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostPreparingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl & {
            source: import("../../lib/types/application/application.js").BaseApplicationSource;
        } & {
            application: import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>;
        };
        DefaultTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithEntities<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        WritingTaskParam: import("../../lib/types/application/tasks.js").WritingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        WritingEntitiesTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithEntities<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostWritingTaskParam: import("../../lib/types/application/tasks.js").PostWritingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostWritingEntitiesTaskParam: import("../../lib/types/application/tasks.js").PostWritingEntitiesTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreConflictsTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        InstallTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostInstallTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        EndTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
    }>[]>;
    /**
     * Compose with a jhipster generator using default jhipster config, but queue it immediately.
     */
    dependsOnJHipster(generator: string, options?: ComposeOptions<BaseApplicationGenerator>): Promise<BaseApplicationGenerator<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>, {
        InitializingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        PromptingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        ConfiguringTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        ComposingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl;
        LoadingTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplicationDefaults<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingTaskParam: import("../../lib/types/application/tasks.js").PreparingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        ConfiguringEachEntityTaskParam: import("../../lib/types/application/tasks.js").ConfiguringEachEntityTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        LoadingEntitiesTaskParam: import("../../lib/types/application/tasks.js").LoadingEntitiesTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingEachEntityTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingEachEntityFieldTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityFieldTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreparingEachEntityRelationshipTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityRelationshipTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostPreparingEachEntityTaskParam: import("../../lib/types/application/tasks.js").PreparingEachEntityTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostPreparingTaskParam: import("../../lib/types/base/tasks.js").TaskParamWithControl & {
            source: import("../../lib/types/application/application.js").BaseApplicationSource;
        } & {
            application: import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>;
        };
        DefaultTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithEntities<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        WritingTaskParam: import("../../lib/types/application/tasks.js").WritingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        WritingEntitiesTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithEntities<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostWritingTaskParam: import("../../lib/types/application/tasks.js").PostWritingTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostWritingEntitiesTaskParam: import("../../lib/types/application/tasks.js").PostWritingEntitiesTaskParam<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PreConflictsTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        InstallTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        PostInstallTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
        EndTaskParam: import("../../lib/types/application/tasks.js").TaskParamWithApplication<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../base-application/index.js").Entity<import("../base-application/index.js").Field, never>>>;
    }>[]>;
    /**
     * Remove File
     * @param file
     */
    removeFile(...path: string[]): string;
    /**
     * Remove Folder
     * @param path
     */
    removeFolder(...path: string[]): void;
    /**
     * Fetch files from the generator-jhipster instance installed
     */
    fetchFromInstalledJHipster(...path: string[]): string;
    /**
     * Utility function to write file.
     *
     * @param source
     * @param destination - destination
     * @param data - template data
     * @param options - options passed to ejs render
     * @param copyOptions
     */
    writeFile(source: string, destination: string, data?: TemplateData, options?: TemplateOptions, copyOptions?: CopyOptions): void;
    /**
     * write the given files using provided options.
     */
    writeFiles<DataType = any>(options: WriteFileOptions<DataType, this>): Promise<string[]>;
    /**
     * Edit file content.
     * Edits an empty file if `options.create` is truthy or no callback is passed.
     * @example
     * // Throws if `foo.txt` doesn't exists or append the content.
     * editFile('foo.txt', content => content + 'foo.txt content');
     * @example
     * // Appends `foo.txt` content if whether exists or not.
     * editFile('foo.txt', { create: true }, content => content + 'foo.txt content');
     * @example
     * // Appends `foo.txt` content if whether exists or not using the returned cascaded callback.
     * editFile('foo.txt')(content => content + 'foo.txt content');
     */
    editFile(file: string, ...transformCallbacks: EditFileCallback<this>[]): CascatedEditFileCallback<this>;
    editFile(file: string, options: EditFileOptions, ...transformCallbacks: EditFileCallback<this>[]): CascatedEditFileCallback<this>;
    /**
     * Convert value to a yaml and write to destination
     */
    writeDestinationYaml(filepath: string, value: Record<string | number, any>): void;
    /**
     * Merge value to an existing yaml and write to destination
     * Removes every comment (due to parsing/merging process) except the at the top of the file.
     */
    mergeDestinationYaml(filepath: string, value: Record<string | number, any>): void;
    /**
     * Merge value to an existing json and write to destination
     */
    mergeDestinationJson(filepath: string, value: Record<string | number, any>): void;
    /**
     * Shallow clone or convert dependencies to placeholder if needed.
     */
    prepareDependencies(map: Record<string, string>, valuePlaceholder?: 'java' | 'docker' | ((value: string) => string)): Record<string, string>;
    loadNodeDependencies(destination: Record<string, string>, source: Record<string, string>): void;
    /**
     * Load Java dependencies from a gradle catalog file.
     * @param javaDependencies
     * @param gradleCatalog Gradle catalog file path, true for generator-jhipster's generator catalog of falsy for blueprint catalog
     */
    loadJavaDependenciesFromGradleCatalog(javaDependencies: Record<string, string>, gradleCatalog?: string | boolean): void;
    loadNodeDependenciesFromPackageJson(destination: Record<string, string>, packageJsonFile?: string): void;
    /**
     * Print ValidationResult info/warnings or throw result Error.
     */
    validateResult(result: ValidationResult, { throwOnError }?: {
        throwOnError?: boolean | undefined;
    }): void;
    /**
     * Checks if there is a newer JHipster version available.
     */
    protected checkForNewVersion(): Promise<void>;
    /**
     * Create a simple-git instance using current destinationPath as baseDir.
     */
    createGit(): import("simple-git").SimpleGit;
    private calculateApplicationId;
    protected getSharedApplication(applicationFolder?: string): any;
    private createSharedData;
}
