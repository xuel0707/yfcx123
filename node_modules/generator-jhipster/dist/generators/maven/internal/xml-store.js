/**
 * Copyright 2013-2024 the original author or authors from the JHipster project.
 *
 * This file is part of the JHipster project, see https://www.jhipster.tech/
 * for more information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import assert from 'assert';
import { XMLBuilder, XMLParser } from 'fast-xml-parser';
import { merge } from 'lodash-es';
const defaultXmlCommonOptions = {
    ignoreAttributes: false,
    attributeNamePrefix: '@@',
    commentPropName: '#comment',
};
export const defaultXmlParserOptions = {
    parseAttributeValue: false,
    parseTagValue: false,
    ...defaultXmlCommonOptions,
};
export const defaultXmlBuildOptions = {
    ...defaultXmlCommonOptions,
    suppressBooleanAttributes: false,
    suppressEmptyNode: true,
    format: true,
    indentBy: '    ',
};
export default class XmlStorage {
    sortFile;
    saveFile;
    loadFile;
    parser;
    builder;
    _cachedStore;
    constructor({ saveFile, loadFile, xmlParserOptions, xmlBuildOptions, sortFile, }) {
        assert(saveFile, 'saveFile callback is required to create a storage');
        assert(loadFile, 'loadFile callback is required to create a storage');
        this.parser = new XMLParser({ ...defaultXmlParserOptions, ...xmlParserOptions });
        this.builder = new XMLBuilder({ ...defaultXmlBuildOptions, ...xmlBuildOptions });
        this.saveFile = saveFile;
        this.loadFile = loadFile;
        this.sortFile = sortFile ?? true;
    }
    clearCache() {
        delete this._cachedStore;
    }
    save(sort = this.sortFile) {
        if (sort) {
            this.sort();
        }
        this.persist(false);
    }
    merge(source) {
        assert(typeof source === 'object', 'Storage `merge` method only accept objects');
        this._cachedStore = merge({}, this.store, source);
    }
    sort() { }
    persist(sort = this.sortFile) {
        if (this._cachedStore) {
            if (sort) {
                this.sort();
            }
            this.saveFile(this.builder.build(this._cachedStore));
        }
    }
    get store() {
        this.load();
        return this._cachedStore;
    }
    load() {
        if (!this._cachedStore) {
            this._cachedStore = this.parser.parse(this.loadFile());
        }
    }
    mergeContent(existing, newContent) {
        return newContent ? { ...existing, ...this.parser.parse(newContent) } : existing;
    }
}
